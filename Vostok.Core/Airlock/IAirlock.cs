using System;
using System.IO;

namespace Vostok.Airlock
{
    // (iloktionov): На первый взгляд кажется, что Airlock не должен знать ничего о природе протаскиваемых через него сообщений.
    // С отправляющей стороны знание их формата должно быть у инструментации какой-то подсистемы (трассировки, логов, метрик).
    // С принимающей же стороны - у демонов, перекладывающих данные из Кафки куда-то.
    // Задачи клиента к Airlock'у:
    // 1. Доставлять до шлюза блобы, снабженные произвольными метками. Эти метки позволят делать какой-то routing и выбирать на читающей стороне десериализатор.
    // 2. Быть кошмарно производительным.
    // 3. Не влиять на работу приложения, даже когда шлюз прилег.
    // Поэтому первый вариант фасада позволяет ровно это: выкинуть в шлюз бинарное мясо с какой-то меткой в формате fire'n'forget.
    // Я для начала привел два варианта: более симпатичные и более надежный/производительный.

    public interface IAirlock
    {
        // Этот вариант выглядит очень просто, но возлагает на вызывающий код ответственность за управление буферами для сериализации.
        // Управлять ими эффективно одновременно в нескольких инструментациях может оказаться неудобно и накладно.
        void Throw(string category, ArraySegment<byte> data);

        // Этот вариант откровенно более уродливый, зато берет на себя всю сложность по эффективному использованию буферов.
        // В нем разработчики инструментации сериализуют свои сообщения на лету в предоставляемый sink.
        // Ленивые - через stream, энтузиасты могут добиться максимальной эффективности за счет ручной сериализации.
        void Throw(string category, Action<IAirlockSink> dataWriter);
    }

    public interface IAirlockSink
    {
        Stream WriteStream { get; }

        void Write(int value);
        void Write(long value);
        void Write(byte value);
        void Write(byte[] value);
        void Write(string value);
        void Write(double value);
        // ...
    }
}
